
/*
 * A V4L2 driver for TP9953 YUV cameras.
 *
 * Copyright (c) 2022 by Allwinnertech Co., Ltd.  http://www.allwinnertech.com
 *
 * Authors:  maliankang <maliankang@allwinnertech.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <hal_timer.h>

#include "../../vin_mipi/combo_common.h"
#include "camera.h"
#include "../../utility/sunxi_camera_v2.h"
#include "../../utility/media-bus-format.h"
#include "../../utility/vin_supply.h"


#define MCLK              (27*1000*1000)
#define CLK_POH           V4L2_MBUS_PCLK_SAMPLE_RISING
#define CLK_POL           V4L2_MBUS_PCLK_SAMPLE_FALLING
#define V4L2_IDENT_SENSOR 0x6328


/* enable tp9953 sensor detect */
#define SENSOR_DETECT_KTHREAD 1
/* USE DETECT BY GPIO_IRQ OR POLLING
 * DET_USE_POLLING 0 meant by gpio_irq
 * DET_USE_POLLING 1 meant by POLLING
 * */
#define DET_USE_POLLING 1

/*
 * Our nominal (default) frame rate.
 */
#define SENSOR_FRAME_RATE 30
static int sensor_power_count[2];
static int sensor_stream_count[2];
static struct sensor_format_struct *current_win[2];
static struct sensor_format_struct *current_switch_win[2];

/*
 * The default register settings
 */
static struct regval_list sensor_default_regs[] = {

};
/*
 * The TP9920 sits on i2c with ID 0x88 or 0x8a
 * SAD-low:0x88 SAD-high:0x8a
 */
#define I2C_ADDR 0x88
#define SENSOR_NAME "tp9953"
static struct regval_list reg_dump[] = {
	{0x00, 0x00},
	{0x01, 0x00},
	{0x02, 0x00},
	{0x03, 0x00},
	{0x04, 0x00},
	{0x05, 0x00},
	{0x06, 0x00},
	{0x07, 0x00},
	{0x08, 0x00},
	{0x09, 0x00},
	{0x0a, 0x00},
	{0x0b, 0x00},
	{0x0c, 0x00},
	{0x0d, 0x00},
	{0x0e, 0x00},
	{0x0f, 0x00},

	{0x10, 0x00},
	{0x11, 0x00},
	{0x12, 0x00},
	{0x13, 0x00},
	{0x14, 0x00},
	{0x15, 0x00},
	{0x16, 0x00},
	{0x17, 0x00},
	{0x18, 0x00},
	{0x19, 0x00},
	{0x1a, 0x00},
	{0x1b, 0x00},
	{0x1c, 0x00},
	{0x1d, 0x00},
	{0x1e, 0x00},
	{0x1f, 0x00},

	{0x20, 0x00},
	{0x21, 0x00},
	{0x22, 0x00},
	{0x23, 0x00},
	{0x24, 0x00},
	{0x25, 0x00},
	{0x26, 0x00},
	{0x27, 0x00},
	{0x28, 0x00},
	{0x29, 0x00},
	{0x2a, 0x00},
	{0x2b, 0x00},
	{0x2c, 0x00},
	{0x2d, 0x00},
	{0x2e, 0x00},
	{0x2f, 0x00},

	{0x30, 0x00},
	{0x31, 0x00},
	{0x32, 0x00},
	{0x33, 0x00},
	{0x34, 0x00},
	{0x35, 0x00},
	{0x36, 0x00},
	{0x37, 0x00},
	{0x38, 0x00},
	{0x39, 0x00},
	{0x3a, 0x00},
	{0x3b, 0x00},
	{0x3c, 0x00},
	{0x3d, 0x00},
	{0x3e, 0x00},
	{0x3f, 0x00},

	{0x40, 0x00},
	{0x41, 0x00},
	{0x42, 0x00},
	{0x43, 0x00},
	{0x44, 0x00},
	{0x45, 0x00},
	{0x46, 0x00},
	{0x47, 0x00},
	{0x48, 0x00},
	{0x49, 0x00},
	{0x4a, 0x00},
	{0x4b, 0x00},
	{0x4c, 0x00},
	{0x4d, 0x00},
	{0x4e, 0x00},
	{0x4f, 0x00},

	{0x50, 0x00},
	{0x51, 0x00},
	{0x52, 0x00},
	{0x53, 0x00},
	{0x54, 0x00},
	{0x55, 0x00},
	{0x56, 0x00},
	{0x57, 0x00},
	{0x58, 0x00},
	{0x59, 0x00},
	{0x5a, 0x00},
	{0x5b, 0x00},
	{0x5c, 0x00},
	{0x5d, 0x00},
	{0x5e, 0x00},
	{0x5f, 0x00},

	{0x61, 0x00},
	{0x62, 0x00},
	{0x63, 0x00},
	{0x64, 0x00},
	{0x65, 0x00},
	{0x66, 0x00},
	{0x67, 0x00},
	{0x68, 0x00},
	{0x69, 0x00},
	{0x6a, 0x00},
	{0x6b, 0x00},
	{0x6c, 0x00},
	{0x6d, 0x00},
	{0x6e, 0x00},
	{0x6f, 0x00},

	{0x70, 0x00},
	{0x71, 0x00},
	{0x72, 0x00},
	{0x73, 0x00},
	{0x74, 0x00},
	{0x75, 0x00},
	{0x76, 0x00},
	{0x77, 0x00},
	{0x78, 0x00},
	{0x79, 0x00},
	{0x7a, 0x00},
	{0x7b, 0x00},
	{0x7c, 0x00},
	{0x7d, 0x00},
	{0x7e, 0x00},
	{0x7f, 0x00},

	{0x80, 0x00},
	{0x81, 0x00},
	{0x82, 0x00},
	{0x83, 0x00},
	{0x84, 0x00},
	{0x85, 0x00},
	{0x86, 0x00},
	{0x87, 0x00},
	{0x88, 0x00},
	{0x89, 0x00},
	{0x8a, 0x00},
	{0x8b, 0x00},
	{0x8c, 0x00},
	{0x8d, 0x00},
	{0x8e, 0x00},
	{0x8f, 0x00},

	{0x90, 0x00},
	{0x91, 0x00},
	{0x92, 0x00},
	{0x93, 0x00},
	{0x94, 0x00},
	{0x95, 0x00},
	{0x96, 0x00},
	{0x97, 0x00},
	{0x98, 0x00},
	{0x99, 0x00},
	{0x9a, 0x00},
	{0x9b, 0x00},
	{0x9c, 0x00},
	{0x9d, 0x00},
	{0x9e, 0x00},
	{0x9f, 0x00},

	{0xa0, 0x00},
	{0xa1, 0x00},
	{0xa2, 0x00},
	{0xa3, 0x00},
	{0xa4, 0x00},
	{0xa5, 0x00},
	{0xa6, 0x00},
	{0xa7, 0x00},
	{0xa8, 0x00},
	{0xa9, 0x00},
	{0xaa, 0x00},
	{0xab, 0x00},
	{0xac, 0x00},
	{0xad, 0x00},
	{0xae, 0x00},
	{0xaf, 0x00},

	{0xb0, 0x00},
	{0xb1, 0x00},
	{0xb2, 0x00},
	{0xb3, 0x00},
	{0xb4, 0x00},
	{0xb5, 0x00},
	{0xb6, 0x00},
	{0xb7, 0x00},
	{0xb8, 0x00},
	{0xb9, 0x00},
	{0xba, 0x00},
	{0xbb, 0x00},
	{0xbc, 0x00},
	{0xbd, 0x00},
	{0xbe, 0x00},
	{0xbf, 0x00},

	{0xc0, 0x00},
	{0xc1, 0x00},
	{0xc2, 0x00},
	{0xc3, 0x00},
	{0xc4, 0x00},
	{0xc5, 0x00},
	{0xc6, 0x00},
	{0xc7, 0x00},
	{0xc8, 0x00},
	{0xc9, 0x00},
	{0xca, 0x00},
	{0xcb, 0x00},
	{0xcc, 0x00},
	{0xcd, 0x00},
	{0xce, 0x00},
	{0xcf, 0x00},

	{0xd0, 0x00},
	{0xd1, 0x00},
	{0xd2, 0x00},
	{0xd3, 0x00},
	{0xd4, 0x00},
	{0xd5, 0x00},
	{0xd6, 0x00},
	{0xd7, 0x00},
	{0xd8, 0x00},
	{0xd9, 0x00},
	{0xda, 0x00},
	{0xdb, 0x00},
	{0xdc, 0x00},
	{0xdd, 0x00},
	{0xde, 0x00},
	{0xdf, 0x00},

	{0xf0, 0x00},
	{0xf1, 0x00},
	{0xf2, 0x00},
	{0xf3, 0x00},
	{0xf4, 0x00},
	{0xf5, 0x00},
	{0xf6, 0x00},
	{0xf7, 0x00},
	{0xf8, 0x00},
	{0xf9, 0x00},
	{0xfa, 0x00},
	{0xfb, 0x00},
	{0xfc, 0x00},
	{0xfd, 0x00},
	{0xfe, 0x00},
	{0xff, 0x00},
};

#if 0
static struct regval_list reg_1080p30_2ch[] = {
	{0x40, 0x04},
	{0x02, 0xc8},
	{0x0d, 0x70},
	{0x14, 0x40},
	{0x1c, 0x88},
	{0x1d, 0x96},
	{0x15, 0x03},
	{0x16, 0xd0},
	{0x17, 0x80},
	{0x18, 0x2a},
	{0x19, 0x38},
	{0x1a, 0x47},
	{0x20, 0x38},
	{0x27, 0xad},

	/*******/
	{0x2a, 0x3C},
	/********/

	{0x2d, 0x48},
	{0x30, 0x52},
	{0x31, 0xca},
	{0x32, 0xf0},
	{0x33, 0x20},
	{0x42, 0xf3},
	{0x44, 0x51},
	{0x51, 0x00},
	{0xe8, 0x05},
	{0xea, 0x01},
	{0xeb, 0x01},
	{0xf1, 0x30},
	{0xf6, 0x10},
	{0x40, 0x08},
	{0x02, 0x80},
	{0x03, 0x80},
	{0x04, 0x80},
	{0x05, 0x80},
	{0x06, 0x80},
	{0x13, 0xef},
	{0x15, 0x00},


};
#endif

#if 1
static struct regval_list reg_1080p25_2ch[] = {
	{0x40, 0x04},
	{0x02, 0xc8},
	{0x0d, 0x70},
	{0x1c, 0x8a},
	{0x1d, 0x4e},
	{0x15, 0x03},
	{0x16, 0xd0},
	{0x17, 0x80},
	{0x18, 0x2a},
	{0x19, 0x38},
	{0x1a, 0x47},
	{0x20, 0x3c},
	{0x21, 0x46},
	{0x27, 0xad},
	/*
	 * 0x2a寄存器
	 * 不设置,寄存器默认值为0x30
	 * 设置0x30,无信号出黑屏,有信号出图
	 * 设置0x34,无信号出蓝屏,有信号出图
	 * 设置0x3c,有无信号都出蓝屏
	 */
	{0x2a, 0x34},
	{0x2c, 0x3a},
	{0x2d, 0x48},
	{0x2e, 0x40},
	{0x30, 0x52},
	{0x31, 0xc3},
	{0x32, 0x7d},
	{0x33, 0xa0},
	{0x42, 0xf3},
	/*
	 * 0x44寄存器,设置clk delay
	 * 有的板子阻抗,物料差异要求不一样,可以调整寄存器高4位测试
	 */
	{0x44, 0xf1},
	{0x51, 0x00},
	{0xe8, 0x05},
	{0xea, 0x01},
	{0xeb, 0x01},
	{0xf1, 0x30},
	{0xf6, 0x10},

	//设置通道ID
	{0x40, 0x00},
	{0x34, 0x10},
	{0x40, 0x01},
	{0x34, 0x11},

	{0x40, 0x08},
	{0x02, 0x80},
	{0x03, 0x80},
	{0x04, 0x80},
	{0x05, 0x80},
	{0x06, 0x80},
	{0x13, 0xef},
	{0x15, 0x00},
};
#endif

static int sensor_s_exp(int id, unsigned int exp_val)
{
	return 0;
}

static int sensor_s_exp_gain(int id, struct sensor_exp_gain *exp_gain)
{
    return 0;
}

static int sensor_power(int id, int on)
{
	switch (on) {
	case PWR_ON:
		vin_gpio_write(id, PWDN, CSI_GPIO_HIGH);
		hal_usleep(2000);
		vin_set_mclk_freq(id, MCLK);
		vin_set_mclk(id, 1);
		hal_usleep(2000);
		vin_gpio_write(id, RESET, CSI_GPIO_HIGH);
		hal_usleep(1000);
		break;
	case PWR_OFF:
		vin_set_mclk(id, 0);
		hal_usleep(100);
		vin_gpio_set_status(id, RESET, 0);
		vin_gpio_set_status(id, PWDN, 0);
		hal_usleep(2000);
		break;
	default:
		return -EINVAL;
	}

	return 0;
}

static int sensor_set_ir(int id, int status)
{
    return 0;
}

static int sensor_detect(int id)
{
	data_type rdval, rdval1, rdval2;
	int cnt = 0;

	rdval = 0;
	rdval1 = 0;
	rdval2 = 0;

	sensor_write(id, 0x40, 0x00);
	sensor_read(id, 0xff, &rdval2);
	sensor_read(id, 0xfe, &rdval1);
	rdval = ((rdval2<<8) & 0xff00) | rdval1;
	sensor_print("L:[%d] V4L2_IDENT_SENSOR = 0x%x\n", __LINE__, rdval);
#if 1
	while ((rdval != V4L2_IDENT_SENSOR) && (cnt < 5)) {
		sensor_read(id, 0xff, &rdval2);
		sensor_read(id, 0xfe, &rdval1);
		rdval = ((rdval2<<8) & 0xff00) | rdval1;
		sensor_print("retry = %d, V4L2_IDENT_SENSOR = 0x%x\n", cnt,
				rdval);
		cnt++;
	}

	if (rdval != V4L2_IDENT_SENSOR)
		return -ENODEV;
#endif
	sensor_print("[%s]-[%s]-[%d]:\n", __FILE__, __func__, __LINE__);
	return 0;
}

static int sensor_init(int id)
{
	int ret;

	/*Make sure it is a target sensor */
	ret = sensor_detect(id);
	if (ret) {
		sensor_err("chip found is not an target chip.\n");
		return ret;
	}
	return 0;
}

/*
 * Store information about the video data format.
 */
static struct sensor_format_struct sensor_formats[] = {
	{
//		.desc = "BT656 2CH",
		.mbus_code = MEDIA_BUS_FMT_UYVY8_2X8,
		//	.mbus_code = MEDIA_BUS_FMT_YUYV8_1X16,
		.width = HD1080_WIDTH,
		.height = HD1080_HEIGHT,
		.hoffset = 0,
		.voffset = 0,
		.fps_fixed = 25,
		.regs = reg_1080p25_2ch,
		.regs_size = ARRAY_SIZE(reg_1080p25_2ch),
//		.bpp = 2,
	},
};
#define N_FMTS ARRAY_SIZE(sensor_formats)


static struct sensor_format_struct *sensor_get_format(int id, int isp_id, int vinc_id)
{
	if (current_win[id])
		return current_win[id];

	current_win[id] = &sensor_formats[0];
	sensor_print("fine wdr is %d, fps is %d\n", sensor_formats[0].wdr_mode, sensor_formats[0].fps_fixed);
	return &sensor_formats[0];
}

static struct sensor_format_struct switch_sensor_formats[] = {

};

static struct sensor_format_struct *sensor_get_switch_format(int id, int isp_id)
{
	return NULL;
}

static int sensor_g_mbus_config(int id, struct v4l2_mbus_config *cfg, struct mbus_framefmt_res *res)
{
	cfg->type = V4L2_MBUS_BT656;
	cfg->flags = CLK_POL | CLK_POH | CSI_CH_0 | CSI_CH_1;
	//cfg->flags = CLK_POL | CSI_CH_0;
	return 0;
}

static int sensor_reg_init(int id, int isp_id)
{
	int ret = 0;
	int ispid = clamp(isp_id, 0, ISP_GET_CFG_NUM - 1);
	sensor_dbg("sensor_reg_init\n");

	ret = sensor_write_array(id, sensor_default_regs,
					 ARRAY_SIZE(sensor_default_regs));
	if (ret < 0) {
		sensor_err("write sensor_default_regs error\n");
		return ret;
	}
	if (current_win[id]->regs)
		ret = sensor_write_array(id, current_win[id]->regs, current_win[id]->regs_size);
	if (ret < 0)
		return ret;

	return 0;
}

static int sensor_s_stream(int id, int isp_id, int enable)
{
	if (enable && sensor_stream_count[id]++ > 0)
		return 0;
	else if (!enable && (sensor_stream_count[id] == 0 || --sensor_stream_count[id] > 0))
		return 0;

	sensor_dbg("tp9953 %s on = %d, 1920*1080 fps: 25\n", __func__, enable);

	if (!enable)
		return 0;

	return sensor_reg_init(id, isp_id);
}

static int sensor_s_switch(int id)
{
	return 0;
}

static int sensor_test_i2c(int id)
{
	int ret;
	sensor_power(id, PWR_ON);
	ret = sensor_init(id);
	sensor_power(id, PWR_OFF);

	return ret;
}

struct sensor_fuc_core tp9953_dvp_core  = {
	.g_mbus_config = sensor_g_mbus_config,
	.sensor_test_i2c = sensor_test_i2c,
	.sensor_power = sensor_power,
	.s_ir_status = sensor_set_ir,
	.s_stream = sensor_s_stream,
	.s_switch = sensor_s_switch,
	.s_exp_gain = sensor_s_exp_gain,
	.sensor_g_format = sensor_get_format,
	.sensor_g_switch_format = sensor_get_switch_format,
};
